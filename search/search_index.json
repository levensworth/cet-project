{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KMusic: Sistema de recomendaci\u00f3n para m\u00fasica.","text":"<p>Esta es la p\u00e1gina oficial de <code>kmusic</code>, aqu\u00ed podr\u00e1s encontrar toda la informaci\u00f3n sobre el desarrollo y funcionamiento del sistema.</p> <p>Note</p> <p>Ejemplo de la web funcional disponible aqui</p> <p>Note</p> <p>C\u00f3digo fuente disponible aqui</p>"},{"location":"#como-utilizar-el-repositorio","title":"Como utilizar el repositorio:","text":"<ol> <li>Tener el interprete de <code>python</code> instalado en su computadora, para la versi\u00f3n 3.10</li> <li>Tener un editor de texto para desarrollo, <code>VSCode</code> es el que recomendamos.</li> <li>Instalar <code>poetry</code> es una herramienta de manjo de dependencias. Pueden instalarlo con el comando</li> </ol> <pre><code>pip install poetry\n</code></pre> <ol> <li>Descargar el repositorio, pueden hacerlo directo desde la web de github.</li> <li>Desde una terminal, navegar hasta el principio del proyecto. (Estar dentro de la carpeta que descargaron.)</li> <li>Correr el siguiente comando desde la terminal: <pre><code>poetry install\n</code></pre></li> <li>Un vez que el proyecto est\u00e9 instalado, es cuesti\u00f3n de correrlo: <pre><code>poetry run uvicorn mission_control:app \n</code></pre> Al finalizar esto, deber\u00e1n ver un mensaje en la terminal diciendoles en que url pueden acceder.</li> </ol>"},{"location":"#layout","title":"Layout:","text":"<pre><code>.\n\u251c\u2500\u2500 data\n\u2502   \u2514\u2500\u2500 1m_music_dataset.zip\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 docs\n\u2502   \u2502   \u2514\u2500\u2500 index.md\n\u2502   \u2514\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 lab\n\u2502   \u2514\u2500\u2500 eda.ipynb\n\u251c\u2500\u2500 mission_control.py\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 readme.md\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 core\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 knn_engine_impl.py\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 templates\n\u2502   \u251c\u2500\u2500 index.jinja2\n\u2502   \u251c\u2500\u2500 recommendation.jinja2\n\u2502   \u251c\u2500\u2500 search-item.jinja2\n\u2502   \u2514\u2500\u2500 search-results.jinja2\n\u2514\u2500\u2500 tests\n</code></pre> <p>El c\u00f3digo se encuentra disponible bajo la carpeta <code>src</code>. Dentro de la misma encontraremos varios archivos,  pero lo m\u00e1s importante es entender <code>main.py</code> y <code>knn_engine_impl.py</code>. El primero contiene la l\u00f3gica que  utilizamos para mostrar la web, y el segundo cotiene la implementaci\u00f3n del sistema de recomendaci\u00f3n que creamos.</p> <p>En la secci\u00f3n de <code>lab</code> encontraremos un notebook con la experimentaci\u00f3n sobre el dataset que utilizamos, el mismo se encuentra bajo la carpeta <code>data</code>.</p>"},{"location":"intro/","title":"Sistemas de recommendaci\u00f3n:","text":"<p>En esta secci\u00f3n vamos a ver un poco sobre los sistemas de recomendaci\u00f3n y como nuestro peque\u00f1o frankenstein de recomendador entra en este mundo.</p> <p></p> <p>Note</p> <p>Hay mucho m\u00e1s contenido a cerca del tema y se puede encontrar en el siguiente link</p>"},{"location":"intro/#primero-que-es-sistema-de-recommendacion","title":"Primero: Que es sistema de recommendaci\u00f3n:","text":"<p>SI uno busca en internet encuentra multiples definiciones de este termino, con varios grados de certeza y  profundidad. Pero para nuestros fines pr\u00e1cticos vamos a ver una noci\u00f3n que sea v\u00e1lida y sin muchos terminos fancy.</p> <p></p> <p>En criollo, un sistema de recomendaci\u00f3n es simplemente un programa que toma en cuenta ciertas variables de inter\u00e9s, como puede ser tus preferencias previas, alg\u00fan atributo propio del objeto de recomendaci\u00f3n, interacciones previas, etc.</p> <p>La idea, es una caja negra a la que le metemos un par de datos y autom\u00e1gicamente nos devuelve posibles cosas que ,esperamos, sean de nuetro inter\u00e9s.</p> <p></p>"},{"location":"intro/#tipos-de-sistemas","title":"Tipos de sistemas:","text":"<p>Okey, ahora tenemos una idea medio vaga de que es un sistema de recomendaci\u00f3n. Pero tal vez, te estes preguntando como esta idea  funciona para cosas tan distintas como instagram, tiktok, youtube, netflix spotify, etc; y la realidad es que cada uno de esos  productos tiene su peque\u00f1o monstruo interno que est\u00e1 optimizado para cada plataforma. </p> <p></p> <p>Ahora bien, lo que si debemos entender es que hay una distinci\u00f3n entre aquellos sistemas que utilizan datos de otro usuarios,  de aquellos sistemas que se basan unicamente en la informaci\u00f3n del producto y del usuario en particular. El primero, se lo conoce como Collaborative Filtering mientras que el segundo es llamado Content based filtering. Esta distinci\u00f4n, es para saber si el sistema utiliza informaci\u00f3n sobre como otros usuarios interactuaron con un producto para determinar si el mismo es de inter\u00e9s para nosotros o, en su defecto, utiliza informaci\u00f4n \u00fanicamente sobre nuestras prefernecias y las  caracter\u00eesticas de cada producto.</p> <p>La gran diferencia, es que unos se basan en la hipotesis de que si otras personas con gustos similares les interes\u00f3 algo... muy  probablemente nos interese a nosotros tambi\u00e9n. En cambio, el otro tipo de sistemas, se basa \u00fanicamente en nuestro comportamiento individual y lo que conoce de los productos para recomendarnos algo nuevo. </p> <p>En nuestro caso, <code>Kmusic</code> se encuentra dentro de la categoria de Content Based dado que solo utilizamos la poca informaci\u00f3n que nos proporciona el usuario m\u00e1s las carater\u00edsticas que conocemos de cada canci\u00f3n para recoemndar.</p> <p>Note</p> <p>Usualmente las grandes empresas utilizan sistemas hibridos que utilizan ambos tipos de informaci\u00f3n para mejorar los resultados.</p>"},{"location":"intro/#partes-de-un-sistema-de-recomendacion","title":"Partes de un sistema de recomendaci\u00f3n:","text":"<p>En general, un sistema de recomendaci\u00f3n consta de multiples etapas donde cada una puede ser suficientemente compleja como para estudiar  una vida entera y todav\u00eda no entender como funcionan. Pero sin meternos en detalles, tratemos de simplificar en terminos que podamos manejar:</p> <p></p> <p>En este esquema, hay 3 aspectos que nos interesan.</p>"},{"location":"intro/#generacion-de-candidatos","title":"Generaci\u00f3n de candidatos:","text":"<p>Esta etapa se refiere al paso en el que tomamos nuestra base de conocimiento (en nuestro caso, la base de canciones que tenemos) y hacemos una busqueda r\u00e1pida para encontrar elementos que posiblemente sean de interes.  Este paso puede darnos muchos falsos-positivos  (ejemplos que al final no ser\u00e1n de nuestro inter\u00e9s) pero lo importante es que reduce la cantidad de opciones a mirar. No es lo mismo tener que recomendarte 1 canci\u00f3n de un listado de millones que darte una recomendaci\u00f4n de entre 10. </p> <p>Note</p> <p>Piesen en el tiempo que tardar\u00edan en elegir 2 gustos de helado de un tablero de 50 posibilidades, comparado al tiempo que tardar\u00edan si solo tuvieran 5 opciones. Este fenomeno es conocido como \"The paradox of choice\" y nos afecta en muchos aspectos de la vida cotidiana.</p>"},{"location":"intro/#scoring","title":"Scoring:","text":"<p>En la etapa de Scoring lo que hacemos es tomar cada uno de los elementos que nos devolvi\u00f3 la etapa atenrior y re evaluamos si  realmente son de inter\u00e9s para el usuario o no. Usualemnte esta etapa es donde se corren algoritmos m\u00e1s avanzados de inteligencia artificial como redes neuronales. El objetivo es eliminar posibles falsos positivos y dejar solo elementos que sean relevantes.</p>"},{"location":"intro/#reranking","title":"ReRanking:","text":"<p>Finalmente, luego de filtrar solo los elementos relevantes pasamos al \u00faltimo paso que es re ranking. Aqu\u00ed es donde determinamos cual  es el mejor orden para mostrar los resultados al usuario. Bien sabemos que el usuario promedio prefiere hacer una segunda b\u00fasqueda que  mirar una lista muy larga (y si piensan que no .... preguntense cuantas veces llegan a la p\u00e1gina 2 o 3 de google cuando buscan algo).</p> <p>Este proceso es completamente dominado por el conocimiento que tenemos del usuario, dependientemente de si estamos creando un sistema de tipo colaborative filtering o content based.</p>"},{"location":"kmusic/","title":"Kmusic","text":"<p>En esta secci\u00f3n vamos a analizar como est\u00e1 compuesto <code>Kmuisc</code>, es recomendable haber le\u00eddo la introducci\u00f4n a sistemas de recommendaci\u00f3n dado que ah\u00ed se enuncian ciertos conceptos generales  que utilizaremos.</p>"},{"location":"kmusic/#data","title":"Data:","text":"<p>EN todo proyecto de AI -  algo fundamental es entender que data tenemos disponible. En nuestro caso, dado estaremos utilizando un conjunto de 1 mill\u00f3n de canciones publicado utilizando la base de datos  de Spotify. </p> <p>Este conjunto de datos, tiene las siguientes caracter\u00edsticas sobre cada canci\u00f3n:</p> <ul> <li><code>artist_name</code></li> <li><code>track_name</code></li> <li><code>track_id</code></li> <li><code>popularity</code></li> <li><code>year</code></li> <li><code>genre</code></li> <li><code>danceability</code></li> <li><code>energy</code></li> <li><code>key</code></li> <li><code>loudness</code></li> <li><code>mode</code></li> <li><code>speechiness</code></li> <li><code>acousticness</code></li> <li><code>instrumentalness</code></li> <li><code>liveness</code></li> <li><code>valence</code></li> <li><code>tempo</code></li> <li><code>duration_ms</code></li> <li><code>time_signature</code></li> </ul> <p>La explicaci\u00f3n sobre que representa cada una y su detalle sobre la composici\u00f3n se puede ver aqui. Para nuestro caso, utilizaremos solo aquellos atributos que tengan valores continuos (no sean categor\u00edas).</p> <p>El conjunto, posee canciones que datan desde los a\u00f1os 2000 en adelante, por lo que esto es importante a la hora de la distribuci\u00f3n. Dado que los gustos musicales fueron cambian con el pasar de las decadas, hay ciertos patrones sobre atributos como <code>danceability</code> o <code>acousticness</code> que cambiar\u00edan ampliamente en otras epocas musicales.</p>"},{"location":"kmusic/#modelo","title":"Modelo:","text":"<p>Siguiendo el modelo que vimos en la secci\u00f3n de sistemas de recomendaci\u00f3n, podemos decir que nuestro sistema cae en la categor\u00eda de content based filtering dado que nos basamos exlusivamente sobre la informaci\u00f3n que obtenemos de las canciones para dar recomendaciones y no tomamos en cuenta el parecido entre distintos usuarios. Al punto donde si un usuario ingresa dos b\u00fasquedas distintas obtendr\u00e1 resultados completamente distintos.</p> <p>Ahora bien, veamos como es un diagrama sencillo de nuestro modelo:</p> <p></p>"}]}